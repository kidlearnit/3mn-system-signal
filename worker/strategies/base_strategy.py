"""
Base Strategy Classes and Data Models

This module defines the abstract base classes and data models
used by all trading signal strategies.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime
import pandas as pd


@dataclass
class MarketData:
    """Container for market data used by strategies"""
    
    symbol: str
    exchange: str
    timeframe: str
    candles: pd.DataFrame
    timestamp: datetime
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate market data after initialization"""
        if self.candles.empty:
            raise ValueError(f"No candles provided for {self.symbol}")
        
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing_columns = [col for col in required_columns if col not in self.candles.columns]
        
        if missing_columns:
            raise ValueError(f"Missing required columns for {self.symbol}: {missing_columns}")


@dataclass
class Signal:
    """Container for trading signals generated by strategies"""
    
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    confidence: float  # 0.0 to 1.0
    strength: float  # Signal strength (absolute value)
    timeframe: str
    timestamp: datetime
    strategy_name: str
    details: Dict[str, Any]
    
    def __post_init__(self):
        """Validate signal data after initialization"""
        if self.signal_type not in ['BUY', 'SELL', 'HOLD']:
            raise ValueError(f"Invalid signal_type: {self.signal_type}")
        
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got: {self.confidence}")
        
        if self.strength < 0:
            raise ValueError(f"Strength must be non-negative, got: {self.strength}")


class SignalStrategy(ABC):
    """
    Abstract base class for all trading signal strategies.
    
    This class defines the interface that all concrete strategies must implement.
    Strategies are responsible for analyzing market data and generating trading signals.
    """
    
    def __init__(self, name: Optional[str] = None):
        """
        Initialize the strategy.
        
        Args:
            name: Optional name for the strategy. If not provided, 
                  will use the class name.
        """
        self.name = name or self.__class__.__name__
        self._parameters: Dict[str, Any] = {}
    
    @abstractmethod
    def calculate_signal(self, data: MarketData) -> Optional[Signal]:
        """
        Calculate trading signal based on market data.
        
        Args:
            data: Market data containing candles and metadata
            
        Returns:
            Signal object if a signal is generated, None otherwise
            
        Raises:
            ValueError: If market data is invalid
            RuntimeError: If signal calculation fails
        """
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """
        Get the name of this strategy.
        
        Returns:
            Strategy name string
        """
        pass
    
    def get_parameters(self) -> Dict[str, Any]:
        """
        Get strategy parameters.
        
        Returns:
            Dictionary of strategy parameters
        """
        return self._parameters.copy()
    
    def set_parameter(self, key: str, value: Any) -> None:
        """
        Set a strategy parameter.
        
        Args:
            key: Parameter name
            value: Parameter value
        """
        self._parameters[key] = value
    
    def validate_data(self, data: MarketData) -> bool:
        """
        Validate that market data is suitable for this strategy.
        
        Args:
            data: Market data to validate
            
        Returns:
            True if data is valid, False otherwise
        """
        try:
            # Check if we have enough data points
            min_required = self.get_minimum_data_points()
            if len(data.candles) < min_required:
                return False
            
            # Check if data has required columns
            required_columns = ['open', 'high', 'low', 'close', 'volume']
            if not all(col in data.candles.columns for col in required_columns):
                return False
            
            return True
        except Exception:
            return False
    
    def get_minimum_data_points(self) -> int:
        """
        Get minimum number of data points required for this strategy.
        
        Returns:
            Minimum number of candles required
        """
        return 50  # Default minimum
    
    def __str__(self) -> str:
        """String representation of the strategy"""
        return f"{self.get_name()}({self._parameters})"
    
    def __repr__(self) -> str:
        """Detailed string representation of the strategy"""
        return f"{self.__class__.__name__}(name='{self.get_name()}', parameters={self._parameters})"
