{% extends "layouts/base.html" %} {% block content %}

<div class="collector-container w-full mx-auto p-6 bg-white shadow rounded-lg">
  <h2 class="text-lg font-semibold mb-6">Stock Collector</h2>

  <!-- Form th√™m symbol -->
  <div class="mb-6 p-4 bg-gray-50 rounded-lg border">
    <h3 class="text-sm font-medium mb-3">Th√™m m√£ m·ªõi</h3>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
      <!-- Th·ªã tr∆∞·ªùng -->
      <div>
        <label class="block text-xs font-medium text-gray-600">Th·ªã tr∆∞·ªùng</label>
        <div class="flex items-center gap-4 mt-2 text-sm">
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="radio" name="market" value="vn" class="text-indigo-600" checked />
            <span>Vi·ªát Nam</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="radio" name="market" value="us" class="text-indigo-600" />
            <span>Qu·ªëc t·∫ø</span>
          </label>
        </div>
      </div>

      <!-- Nh·∫≠p symbol -->
      <div class="relative">
        <label for="symbol-input" class="block text-xs font-medium text-gray-600">M√£</label>
        <input type="text" id="symbol-input" placeholder="Nh·∫≠p m√£ (AAPL, MSFT, VNM...)"
          class="w-full border rounded px-2 py-1 mt-1 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500" />
        <ul id="symbol-suggestions" class="absolute z-10 mt-1 w-full bg-white border rounded shadow hidden text-sm">
        </ul>
      </div>

      <!-- Button -->
      <div>
        <button id="addSymbolBtn" class="w-full px-3 py-2 rounded bg-blue-600 text-white text-sm hover:bg-blue-700">
          Th√™m
        </button>
      </div>
    </div>
  </div>

  <!-- Filters v√† Controls -->
  <div class="mb-4 flex flex-wrap items-center gap-3">
    <!-- Market Filter -->
    <div class="flex items-center gap-2">
      <label class="text-sm font-medium text-gray-600">L·ªçc theo th·ªã tr∆∞·ªùng:</label>
      <select id="marketFilter"
        class="px-3 py-1 border rounded text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500">
        <option value="all">T·∫•t c·∫£</option>
        <option value="vn">Vi·ªát Nam</option>
        <option value="us">Qu·ªëc t·∫ø</option>
      </select>
    </div>

    <!-- Search Filter -->
    <div class="flex items-center gap-2">
      <label class="text-sm font-medium text-gray-600">T√¨m ki·∫øm:</label>
      <input type="text" id="searchFilter" placeholder="Nh·∫≠p m√£ c·ªï phi·∫øu..."
        class="px-3 py-1 border rounded text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500" />
    </div>

    <!-- Action Buttons -->
    <div class="flex gap-2">
      <button id="startAllBtn" class="px-4 py-2 rounded bg-green-600 text-white text-sm hover:bg-green-700">
        Start t·∫•t c·∫£
      </button>
      <button id="stopAllBtn" class="px-4 py-2 rounded bg-red-600 text-white text-sm hover:bg-red-700">
        Stop t·∫•t c·∫£
      </button>
    </div>
  </div>

  <!-- Status -->
  <pre id="status-box" class="mb-6 p-2 bg-gray-100 border rounded text-xs overflow-y-auto max-h-32">
Tr·∫°ng th√°i collector s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</pre>

  <!-- Test Button -->
  <div class="mb-4">
    <button id="testLoadBtn" class="px-4 py-2 rounded bg-purple-600 text-white text-sm hover:bg-purple-700">
      Test Load Symbols
    </button>
  </div>

  <!-- 2 b·∫£ng VN + US -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <!-- VN -->
    <div class="p-3 bg-gray-50 rounded border">
      <h3 class="text-sm font-medium mb-2">Danh s√°ch m√£ Vi·ªát Nam</h3>
      <div class="overflow-y-auto max-h-80">
        <table class="w-full text-xs border-collapse">
          <thead class="bg-gray-100 text-gray-600">
            <tr>
              <th class="px-2 py-2 text-left">M√£</th>
              <th class="px-2 py-2 text-left">Tr·∫°ng th√°i</th>
              <th class="px-2 py-2 text-left">Thao t√°c</th>
              <th class="px-2 py-2 text-left">Xem d·ªØ li·ªáu</th>
            </tr>
          </thead>
          <tbody id="symbols-vn-body" class="divide-y divide-gray-200 bg-white"></tbody>
        </table>
      </div>
    </div>

    <!-- US -->
    <div class="p-3 bg-gray-50 rounded border">
      <h3 class="text-sm font-medium mb-2">Danh s√°ch m√£ Qu·ªëc t·∫ø</h3>
      <div class="overflow-y-auto max-h-80">
        <table class="w-full text-xs border-collapse">
          <thead class="bg-gray-100 text-gray-600">
            <tr>
              <th class="px-2 py-2 text-left">M√£</th>
              <th class="px-2 py-2 text-left">Tr·∫°ng th√°i</th>
              <th class="px-2 py-2 text-left">Thao t√°c</th>
              <th class="px-2 py-2 text-left">Xem d·ªØ li·ªáu</th>
            </tr>
          </thead>
          <tbody id="symbols-us-body" class="divide-y divide-gray-200 bg-white"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    const symbolInput = document.getElementById("symbol-input");
    const suggestionsBox = document.getElementById("symbol-suggestions");
    const addSymbolBtn = document.getElementById("addSymbolBtn");
    const startAllBtn = document.getElementById("startAllBtn");
    const stopAllBtn = document.getElementById("stopAllBtn");
    const statusBox = document.getElementById("status-box");

    let symbols = []; // Danh s√°ch symbols t·ª´ server
    let filteredSymbols = []; // Danh s√°ch symbols ƒë√£ l·ªçc

    // Socket initialization - comment out for now to test
    // const socket = io("/collector");
    // socket.on("job_status", (jobsStatus) => {
    //   console.log("job_status socket...", jobsStatus);
    //   let hasUpdates = false;
    //   
    //   symbols.forEach((s) => {
    //     if (jobsStatus[s.symbol]) {
    //       const newStatus = jobsStatus[s.symbol];
    //       if (s.status !== newStatus) {
    //         s.status = newStatus;
    //         hasUpdates = true;
    //         
    //         // Log status changes
    //         if (newStatus === "stopping") {
    //           setStatus(`üü° ${s.symbol} ƒëang d·ª´ng...`, "success", true);
    //         } else if (newStatus === "stopped") {
    //           setStatus(`‚ö´ ${s.symbol} ƒë√£ d·ª´ng ho√†n to√†n`, "success", true);
    //         } else if (newStatus === "completed") {
    //           setStatus(`üîµ ${s.symbol} ƒë√£ ho√†n th√†nh`, "success", true);
    //         } else if (newStatus === "failed") {
    //           setStatus(`üî¥ ${s.symbol} g·∫∑p l·ªói`, "error", true);
    //         }
    //       }
    //     }
    //   });
    //   
    //   if (hasUpdates) {
    //     applyFilters(); // Re-render v·ªõi tr·∫°ng th√°i m·ªõi
    //   }
    // });

    // Helper function ƒë·ªÉ set status
    function setStatus(msg, type = "loading", append = false) {
      statusBox.textContent = append ? statusBox.textContent + "\n" + msg : msg;

      statusBox.className =
        "mt-4 p-3 rounded-lg text-sm overflow-y-auto max-h-48";

      if (type === "error")
        statusBox.classList.add("bg-red-100", "text-red-700");
      else if (type === "success")
        statusBox.classList.add("bg-green-100", "text-green-700");
      else statusBox.classList.add("bg-gray-100", "text-gray-700");

      statusBox.scrollTop = statusBox.scrollHeight;
    }

    // T·∫£i danh s√°ch symbols t·ª´ server
    async function loadSymbols() {
      try {
        const res = await fetch("/symbols/list");
        symbols = await res.json();
        applyFilters();
      } catch (err) {
        console.error("L·ªói khi t·∫£i symbols:", err);
        setStatus("‚ùå Kh√¥ng th·ªÉ t·∫£i danh s√°ch symbols", "error");
      }
    }

    // √Åp d·ª•ng b·ªô l·ªçc
    function applyFilters() {
      const marketFilter = document.getElementById("marketFilter").value;
      const searchFilter = document.getElementById("searchFilter").value.toLowerCase();

      filteredSymbols = symbols.filter(symbol => {
        // L·ªçc theo th·ªã tr∆∞·ªùng
        if (marketFilter !== "all" && symbol.market !== marketFilter) {
          return false;
        }

        // L·ªçc theo t√¨m ki·∫øm
        if (searchFilter && !symbol.symbol.toLowerCase().includes(searchFilter)) {
          return false;
        }

        return true;
      });

      renderSymbolsTable();
    }

    function renderSymbolsTable() {
      const vnBody = document.getElementById("symbols-vn-body");
      const usBody = document.getElementById("symbols-us-body");

      vnBody.innerHTML = "";
      usBody.innerHTML = "";

      filteredSymbols.forEach((symbol) => {
        const row = document.createElement("tr");

        // C·ªôt m√£
        const symbolCell = document.createElement("td");
        symbolCell.className = "px-4 py-3 whitespace-nowrap";
        symbolCell.textContent = symbol.symbol;
        row.appendChild(symbolCell);

        // C·ªôt tr·∫°ng th√°i
        const statusCell = document.createElement("td");
        statusCell.className = "px-4 py-3 whitespace-nowrap";
        const statusBadge = document.createElement("span");

        // Enhanced status display with more states
        let statusClass, statusText;
        switch (symbol.status) {
          case "running":
            statusClass = "bg-green-100 text-green-800";
            statusText = "üü¢ ƒêang ch·∫°y";
            break;
          case "stopping":
            statusClass = "bg-yellow-100 text-yellow-800";
            statusText = "üü° ƒêang d·ª´ng";
            break;
          case "stopped":
            statusClass = "bg-gray-100 text-gray-800";
            statusText = "‚ö´ ƒê√£ d·ª´ng";
            break;
          case "completed":
            statusClass = "bg-blue-100 text-blue-800";
            statusText = "üîµ Ho√†n th√†nh";
            break;
          case "failed":
            statusClass = "bg-red-100 text-red-800";
            statusText = "üî¥ L·ªói";
            break;
          default:
            statusClass = "bg-gray-100 text-gray-800";
            statusText = "‚ö™ Ch∆∞a ch·∫°y";
        }

        statusBadge.className = `px-2 py-1 text-xs rounded-full ${statusClass}`;
        statusBadge.textContent = statusText;
        statusCell.appendChild(statusBadge);
        row.appendChild(statusCell);

        // C·ªôt thao t√°c
        const actionsCell = document.createElement("td");
        actionsCell.className = "px-4 py-3 whitespace-nowrap";

        if (symbol.status === "running") {
          const stopBtn = document.createElement("button");
          stopBtn.className =
            "px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm";
          stopBtn.textContent = "‚èπ D·ª´ng";
          stopBtn.onclick = () => stopSymbol(symbol.symbol);
          actionsCell.appendChild(stopBtn);
        } else if (symbol.status === "stopping") {
          const stoppingBtn = document.createElement("button");
          stoppingBtn.className =
            "px-3 py-1 bg-yellow-500 text-white rounded cursor-not-allowed text-sm";
          stoppingBtn.textContent = "‚è≥ ƒêang d·ª´ng...";
          stoppingBtn.disabled = true;
          actionsCell.appendChild(stoppingBtn);
        } else {
          // Show start button for stopped, completed, failed, or unknown status
          const startBtn = document.createElement("button");
          startBtn.className =
            "px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 text-sm";
          startBtn.textContent = "‚ñ∂ B·∫Øt ƒë·∫ßu";
          startBtn.onclick = () => startSymbol(symbol.symbol, symbol.market);
          actionsCell.appendChild(startBtn);

          // Show delete button for non-running states
          const deleteBtn = document.createElement("button");
          deleteBtn.className =
            "px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm ml-2";
          deleteBtn.textContent = "üóë X√≥a";
          deleteBtn.onclick = () => deleteSymbol(symbol.symbol);
          actionsCell.appendChild(deleteBtn);
        }

        row.appendChild(actionsCell);

        // C·ªôt xem d·ªØ li·ªáu
        const viewCell = document.createElement("td");
        viewCell.className = "px-4 py-3 whitespace-nowrap";
        const viewLink = document.createElement("a");
        viewLink.href = `/query?symbol=${symbol.symbol}`;
        viewLink.target = "_blank";
        viewLink.className = "text-indigo-600 hover:text-indigo-900";
        viewLink.textContent = "Xem d·ªØ li·ªáu";
        viewCell.appendChild(viewLink);
        row.appendChild(viewCell);

        // Append v√†o b·∫£ng VN ho·∫∑c US
        if (symbol.market === "vn") {
          vnBody.appendChild(row);
        } else {
          usBody.appendChild(row);
        }
      });
    }

    // Th√™m symbol m·ªõi
    addSymbolBtn.addEventListener("click", addSymbolHandler); // G√°n h√†m v√†o s·ª± ki·ªán

    // Cho ph√©p nh·∫•n Enter ƒë·ªÉ th√™m m√£
    symbolInput.addEventListener('keypress', function (e) {
      if (e.key === 'Enter') {
        addSymbolHandler();
      }
    });

    // Th√™m symbol m·ªõi
    async function addSymbolHandler() {
      const symbol = symbolInput.value.trim().toUpperCase();
      const market = document.querySelector(
        'input[name="market"]:checked'
      ).value;

      if (!symbol) {
        setStatus("‚ùå Vui l√≤ng nh·∫≠p m√£ symbol", "error");
        return;
      }

      setStatus(`‚è≥ ƒêang th√™m ${symbol}.${market}...`);

      try {
        const res = await fetch("/symbols/add", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ symbol, market }),
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus(`‚úÖ ƒê√£ th√™m ${symbol}.${market} th√†nh c√¥ng`, "success", true);
        symbolInput.value = "";

        // T·∫£i l·∫°i danh s√°ch symbols
        await loadSymbols();

        // T·ª± ƒë·ªông start job cho symbol m·ªõi
        await startSymbol(symbol, market);
      } catch (err) {
        setStatus("‚ùå Request th·∫•t b·∫°i: " + err, "error");
      }
    };

    // Start m·ªôt symbol c·ª• th·ªÉ
    async function startSymbol(symbol, market) {
      setStatus(`‚è≥ ƒêang start job cho ${symbol}...`);

      try {
        const res = await fetch("/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ symbol, market }),
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus(`‚ñ∂ Collector started for ${symbol}`, "success", true);

        // T·∫£i l·∫°i danh s√°ch symbols ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
        await loadSymbols();

        // B·∫Øt ƒë·∫ßu polling n·∫øu ch∆∞a c√≥
      } catch (err) {
        setStatus("‚ùå Request th·∫•t b·∫°i: " + err, "error");
      }
    }

    // Stop m·ªôt symbol c·ª• th·ªÉ
    async function stopSymbol(symbol) {
      setStatus(`‚èπ ƒêang g·ª≠i l·ªánh d·ª´ng cho ${symbol}...`);

      try {
        const res = await fetch("/stop", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ symbol }),
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus(`‚úÖ ${data.message || `ƒê√£ g·ª≠i l·ªánh d·ª´ng cho ${symbol}`}`, "success", true);

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i ngay l·∫≠p t·ª©c ƒë·ªÉ hi·ªÉn th·ªã "stopping"
        const symbolObj = symbols.find(s => s.symbol === symbol);
        if (symbolObj) {
          symbolObj.status = "stopping";
          applyFilters(); // Re-render v·ªõi tr·∫°ng th√°i m·ªõi
        }

        // T·∫£i l·∫°i danh s√°ch symbols sau 3 gi√¢y ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i cu·ªëi c√πng
        setTimeout(async () => {
          await loadSymbols();
        }, 3000);

      } catch (err) {
        setStatus("‚ùå Request stop th·∫•t b·∫°i: " + err, "error");
      }
    }

    // X√≥a m·ªôt symbol
    async function deleteSymbol(symbol) {
      if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${symbol} kh·ªèi danh s√°ch?`)) return;

      setStatus(`üóë ƒêang x√≥a ${symbol}...`);

      try {
        const res = await fetch("/symbols/delete", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ symbol }),
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus(`‚úÖ ƒê√£ x√≥a ${symbol} th√†nh c√¥ng`, "success", true);

        // T·∫£i l·∫°i danh s√°ch symbols
        await loadSymbols();
      } catch (err) {
        setStatus("‚ùå Request x√≥a th·∫•t b·∫°i: " + err, "error");
      }
    }

    // Start t·∫•t c·∫£ symbols
    startAllBtn.addEventListener("click", async () => {
      setStatus("‚è≥ ƒêang start t·∫•t c·∫£ jobs...");

      try {
        const res = await fetch("/start-all", {
          method: "POST",
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus("‚ñ∂ ƒê√£ start t·∫•t c·∫£ collectors", "success", true);

        // T·∫£i l·∫°i danh s√°ch symbols ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
        await loadSymbols();

        // B·∫Øt ƒë·∫ßu polling n·∫øu ch∆∞a c√≥
      } catch (err) {
        setStatus("‚ùå Request th·∫•t b·∫°i: " + err, "error");
      }
    });

    // Stop t·∫•t c·∫£ symbols
    stopAllBtn.addEventListener("click", async () => {
      setStatus("‚èπ ƒêang d·ª´ng t·∫•t c·∫£ jobs...");

      try {
        const res = await fetch("/stop-all", {
          method: "POST",
        });
        const data = await res.json();

        if (data.error) {
          setStatus("‚ùå " + data.error, "error");
          return;
        }

        setStatus("‚èπ ƒê√£ d·ª´ng t·∫•t c·∫£ collectors", "success", true);

        // T·∫£i l·∫°i danh s√°ch symbols ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
        await loadSymbols();

        // D·ª´ng polling n·∫øu kh√¥ng c√≤n job n√†o ch·∫°y
      } catch (err) {
        setStatus("‚ùå Request th·∫•t b·∫°i: " + err, "error");
      }
    });

    // Kh·ªüi t·∫°o
    document.addEventListener("DOMContentLoaded", () => {
      loadSymbols();

      // Th√™m event listeners cho filters
      document.getElementById("marketFilter").addEventListener("change", applyFilters);
      document.getElementById("searchFilter").addEventListener("input", applyFilters);

      // Test button
      document.getElementById("testLoadBtn").addEventListener("click", () => {
        console.log("Test button clicked");
        loadSymbols();
      });
    });
  })();
</script>
{% endblock %}